## GoF 23

> 一种思维，一种态度，一种进步。

## 创建型模式

> 如何创建对象，让创建和使用分离

**单例模式**、**工厂模式**、抽象工厂模式、建造者模式、原型模式。

## 结构型模式

> 让类或对象按照某种布局组成更大的模式

适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。

## 行为型模式

> 描述类或对象之间，如何相互协作，共同完成单个类或对象无法完成的任务，行为型模式主要是分配职责

模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

# OOP 七大原则

- **开闭原则**：对扩展开放，对修改关闭

- **里氏替换原则**：继承必须保证父类的所拥有的东西在子类中也有
- **依赖倒置原则**：要面向接口编程，不要面向实现编程。高层的模块不应该依赖底层的模块，两个模块应该都依赖于他们的抽象模块（抽象不依赖细节，细节依赖抽象）
- **单一职责原则**：控制类的粒度大小，保证一个类或者一个方法只做一件事
- **接口隔离原则**：要为各个类建立它们需要的专用接口（接口与实现类）
- **迪米特法则**：只与你的直接朋友交谈，不跟“陌生人”说话（A ---> B--->C，A 不要和 C 交谈）
- **合成复用原则**：尽量先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现

# 单例模式

## 饿汉式

构造器私有，加载时就创建对象。

```java
public class Hungry {
    // 构造器私有
    private Hungry() {}
   
    // 加载时就 new
    private final static Hungry HUNGRY = new Hungry();
    
   	public static Hungry getInstance() {
        return HUNGRY;
    }
}
```

## 懒汉式

构造器私有，但使用时才创建对象。

```java
public class LazyMan {
    private LazyMan() {
        System.out.println(Thread.currentThread().getName());
    }

    private static LazyMan lazyMan;

    private static LazyMan getInstance() {
        if (lazyMan == null) {
            lazyMan = new LazyMan();
        }
        return lazyMan;
    }

    public static void main(String[] args) {
        for (int i = 0; i <10 ; i++) {
            new Thread(() -> {
                LazyMan.getInstance();
            }).start();
        }
    }
}
```

单线程下，这段代码没问题，但是在多线程下，就有问题了。

每次输出的结果都可能不同：

```
Thread-2
Thread-5
Thread-4
Thread-3
Thread-1
Thread-0
```

### 双重检测锁模式下的懒汉式（DCL懒汉式）

```java
public class LazyMan {

    private LazyMan() { }

    private static LazyMan lazyMan;

    // 双重检测
    private static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();
                }
            }
        }
        return lazyMan;
    }
}
```

但 DCL 懒汉式在极端情况下也会出现问题，因为```lazyMan = new LazyMan()```不是一个原子性操作，这行语句会经过三个步骤：

> 1. 分配内存空间s
> 2. 执行构造方法，初始化对象
> 3. 将该对象指向分配的空间
>
> 看起来是一个操作，但是在 cpu 底层会发生指令重排的现象
>
> 比如说，我们期望的结果是：1 -> 2 -> 3，但可能会出现 1 -> 3 -> 2

