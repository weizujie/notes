

# 自我介绍

你好，我叫xxx，2021年毕业南开大学滨海学院，专业电子信息科学与技术，算上实习的话我已经有一年半的工作经验了，一直做的java方面的业务。

# 基础

## 1. 接口和抽象类的区别？

接口主要用于对类的行为进行约束，实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。

一个类只能继承一个类，但可以实现多个接口。

接口中的成员变量只能是```public static final```修饰，不能被修改且必须要有初始值，而抽奖类的成员变量默认是```default```，可在子类中被重新定义，也可以被重新赋值。

## 2. 什么是深拷贝和浅拷贝？

浅拷贝：创建一个新对象，如果原对象里的属性是引用类型的话，浅拷贝会直接复制原对象引用类型的地址，也就是说拷贝对象和原对象使用同一个内部对象（属性）

深拷贝：完全复制整个对象，包括整个对象所包含的内部对象

# 集合

List：有序、可重复

Set：无序、不可重复

Queue：按特定的排队规则来确定先后顺序，有序、可重复

Map：使用键值对来存储，key无序且不可重复，value无序且可重复

## 1. ArrayList和LinkedList的区别？

- ArrayList底层是用数组实现的，元素在内存中的分布是连续的，所以在查改操作上效率高
- 而LinkedList底层是用链表实现，元素在内存中的分布是不连续的，所以在增删操作上效率高

## 2. 如何遍历Map？

**遍历方式一：根据 key 找值方式**

map里有个方法叫keySet()，用来获取map里所有的键，返回的是一个set集合，然后再用for循环遍历就可以拿到对应的值，代码如下：

```java
Set<Integer> keys = map.keySet();
for (Integer key : keys) {
    Integer value = map.get(key);
}  
```

**遍历方式二：键值对方式**

使用map里的entrySet()方法，获取map里所有的键值对（Entry）对象，返回的是一个set集合，也是使用for循环遍历，代码如下：

```java
Set<Entry<Integer,String>> entrySet = map.entrySet();
for (Entry<Integer, String> entry : entrySet) {
    Integer key = entry.getKey();
    String value = entry.getValue();  
}
```

## 3. 什么是迭代器Iterator？

迭代器与for each相似，用来遍历集合的。

## 4. ArrayList如何指定底层数组大小？

无参构造里指定了数组的默认大小是0，只有当调用add()方法进行添加操作时，才会分配一个默认的初始容量10。

如果是有参构造，参数就是指定的容量大小。

## 5. ArrayList怎么对底层数组进行扩容？

扩容操作发生在add()方法内，主要就是创建一个新的数组，将原来数组的元素拷贝到新数组中。

新数组的长度 = 原来数组长度 + 原来数组长度 / 2

如：原来数组的长度为10，那么新数组的长度 = 10 + 10 / 2 = 15

## 6. ArrayList如何删除元素？

和添加一个道理，也是复制元素。

假设删除index=5的元素，首先会复制一份数组，然后把原来数组中index=6元素的位置开始到数组末尾的元素，放到新数组的index=5的位置上。

![img](D:\学习笔记\面试相关\面试题整理.assets\20210318204239.png)

## 7. ArrayList和LinkedList是线程安全的吗？

二者都不是，从add()方法就可以看出来，代码中有一行```elementData[size++] = e```

这个```size++```不是原子性操作，其实是有两步：```elementData[size] = e``` 和 ```size = size + 1```

ArrayList线程安全的版本是 Vector，实现很简单，就是在所有方法上都加上 synchronized 关键字

## 8. 讲讲HashMap的底层结构和实现

**JDK1.8之前**

数组+链表

**JDK1.8之后**

数组+链表+红黑树

# Spring

## 1. 讲讲你对IoC和AOP的理解

**IoC**

控制反转，是一种设计思想，把原本自己掌控的事情交给别人处理，从主动变成被动。比如在java里创建对象一般是自己new对象，现在交给IoC容器管理，在使用的时候直接从容器里拿就行了。

依赖注入，是控制反转的一种实现方式，对象无需自行创建或者管理它的依赖，依赖关系将被自动注入到需要它们的对象中。

**AOP**

AOP，就是所谓的面向切面编程，解决的是**非业务**代码的抽取问题。我的理解是在方法的前后增加非业务代码。比如我想计算某个方法的执行时间，就可以使用AOP对这个方法进行增强。

# SpringMVC

## 1. 简述SpringMVC的工作原理

大概是客户端发送请求，有一个组件去拦截请求，根据请求里的uri找到对应的controller进行处理，处理完后返回一个对象，对象中包含了数据模型以及相应的视图信息，根据视图信息找到对应的页面，然后返回给客户端。

# SpringBoot

## 1.SpringBoot自动装配原理

SpringBoot在启动时，有个@EnableAutoConfiurate注解，这个注解会读取spring.factories文件，这个文件里面就是所有可以自动装配的全类名，然后经过一系列验证、去重操作，返回一个数组，数组里包含的就是可以自动装配的类。

# Mybatis

## 1. #{}和${}的区别?

- #{}是sql参数的占位符，Mybatis会将#{}替换为?号，可以避免sql注入
- ${}是properties文件中的变量占位符，可以用在标签属性和sql内部，属于静态文本替换

# MySQL

## 1. 事务隔离级别？

**读未提交**

事务没提交就可以读，会导致脏读

**读已提交**

事务提交后才能读，解决了脏读，但会导致不可重复读

**可重复读（默认）**

为了解决不可重复读，但会导致幻读

**串行化**

所有的事务串起来一个个执行

## 2. 解释一下脏读、幻读、不可重复读

**脏读**

事务A修改了一条数据，但没提交，此时事务B来查询这条数据，查询到的是事务A修改过的，如果事务A此时回滚了，那数据就变为原来的样子，事务B还是查询到的修改后的数据。

**幻读**

事务一开始按某个查询条件没查出任何数据，结果因为另一个事务的影响，再去查时却查到了数据，这种就像产生幻觉了一样，被称作幻读。

**不可重复读**

事务A查询一条数据但事务还没提交，事务B修改了这一条数据并提交了事务，事务A又查询这条数据，变为了事务B修改后的数据。

同一个事务内，查询同一条数据的结果不同，导致了不可重复读。

# Redis

## 1. 缓存血崩、穿透、击穿是什么？如何解决？

**缓存血崩**

大量key在某个时刻同时过期，导致大量请求直接访问数据库，造成数据库压力大。

在给key设置过期时间时，可以使用随机时间，比如缓存七天，在七天的基础上随机加上一个小时或者几分钟，这样就不会同时过期了。

**缓存穿透**

一般来说，使用缓存获取数据的方式是这样的：先从缓存里获取，缓存没有就从数据库获取，数据库有就设置缓存，然后返回数据。如果大量请求来访问一个缓存中不存在的数据，数据库也不存在的数据，这样的话缓存这一层就没什么作用了，也是直接访问到数据库，早餐数据库压力大。

如果访问数据库也不存在的数据时，可以设置缓存的value为一个null值，或者一个没有业务意义的值，这样就不会直接请求到数据库了。在修改这个数据的时候才更新到缓存。

**缓存击穿**

大量请求访问一个已过期的key，也会直接访问到数据库，造成数据库压力大。

可以使用锁，只允许一个请求访问数据库，然后把缓存设置上，这样其他请求过来就不会直接访问到数据库了。

## 2. 为什么redis那么快？

redis是基于内存的，绝大部分操作都是在内存里完成的。而且redis是单线程模型，避免了不必要了上下文切换和竞态条件。

## 3. redis的使用场景？

主要是缓存一些热点数据，比如会员信息这些常用的而且不会实时变化的数据。

还有就是做分布式锁，解决缓存击穿。

## 4. redis的数据结构？

五种基础类型：string、list、set、hash、zset

在项目中最常用就是string和hash，其他没用过。

# RabbitMQ

## 1. 为什么使用消息队列？

主要是为了减少一些业务上的耦合，把不属于主业务的操作给异步化。还有削峰，这个没做过。

## 2. 在哪些场景使用消息队列？

自助积分功能用到了消息队列。该功能的主流程是：校验会员信息，校验积分码是否正确，校验通过后更新会员的积分总值，然后返回给前端结果。除了要更新会员的积分总值外，还要记录会员的每一条积分信息，因为不是主流程，所以就通过消息队列去做，只是简单的保存一条积分记录。

## 3. 如何保证消息不被重复消费？

这个主要是在业务上做幂等，提供一个根据唯一id查询的接口，在插入数据库前先判断一下是否存在这个id的数据，不存在就插入，存在就更新某个字段。

或者在MySQL加一个unique索引，在数据库层面做兜底。

# 设计模式

## 1. 讲讲单例模式、工厂模式和策略模式

**单例模式**

对象在内存中仅有一份，将构造方法私有化禁止外部new对象。

创建单例对象有两种方式：饿汉式和懒汉式。

饿汉式就是一上来就把对象创建出来，要用的时候就返回。缺点是还没用到的时候对象就初始化完成了，早餐资源的浪费。

懒汉式就是用到的时候才创建。

**工厂模式**

简单工厂模式：创建一个类，根据不同的参数去创建不同的对象。

工厂方法模式：创建一个接口，根据不同的参数去实现这个接口。

抽象工厂模式：

**策略模式**

简单来说，就是将一系列算法封装起来，它们可以相互替换，并且算法的变化不会影响到使用者。

## 2. 在项目如何使用工厂模式和策略模式消除if-else？

有个97庆典活动，完成不同的任务可以获得不同的宝箱。

设计了一个接口，校验不同的任务的完成情况，参数就是任务类型。如果不用设计模式的话，会有很多if-else，每一个任务类型都要判断一次，如果新增了任务，就要修改原来的代码，不方便。

把这些任务当成一个个不同的策略（类），把这些类放到一个map里，然后根据key去拿这些策略，然后执行相应的方法。
