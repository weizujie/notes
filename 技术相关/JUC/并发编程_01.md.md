# 1. 进程与线程

## 1.1 进程与线程
### 进程
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载到CPU，将数据加载到内存。在指令运行的过程中，还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理IO的。**
- 当一个程序被运行，从磁盘加载这个程序到内存中，这就开启了一个进程
- 进程可以看做程序的一个实例
### 线程
- 一个进程之内可以分为多个线程
- 一个线程就是一个指令流，指令流中的一条条指令以一定的顺序交给CPU执行
- **Java中，线程作为最小的调度单位，进程作为资源分配的最小单位。**
### 二者对比
- 进程基本上相互独立，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程之间的通信较为复杂：
	- 同一台计算机的进程通信称为IPC
	- 不同计算机之间进程的通信需要通过网络，并遵守共同的协议，如HTTP
- 线程之间的通信较为简单，因为它们共享进程内的内存
- 线程更轻，线程上下文切换成本一般比进程上下文切换要低
## 1.2 并行与并发
并行（parallel）：同一时间动手做（doing）多件事的能力
并发（concurrent）：同一时间应对（dealing with）多件事的能力
简单来理解：并发就是一个人烧水，等水烧开的时候去切菜，而并行就是一个人烧水，一个人切菜
## 1.3 同步和异步
从方法调用的角度来讲，如果
- 需要等待结果返回才能运行，就是同步
- 不需要等待结果返回就能运行，就是异步
> 同步在多线程中也可以看做让多个线程步调一致
# 2. Java线程
## 2.1 创建线程的三种方法
### 方法一，直接使用Thread
```java
// 创建线程对象，构造方法的参数是指定线程的名字
Thread t1 = new Thread("t1") {
	@override
	public void run() {
		// 要执行的任务
		System.out.println("hello");
	}
};
// 启动线程
t1.start();
```
### 方法二，使用Runnable配合Thread
把【线程】和【任务】（要执行的代码）分开
- Thread代表线程
- Runnable代表可运行的任务（线程要执行的代码）
```java
// 创建任务对象
Runnable r = new Runnable() {
	@override
	public void run() {
		System.out.println("hello");
	}
};
// 创建线程对象
Thread t2 = new Thread(r, "t2");
// 启动线程
t2.start();
```
使用lambda简化（推荐）
```java
// 创建任务对象
Runnable r = () -> {System.out.println("hello")};
// 创建线程对象
Thread t2 = new Thread(r, "t2");
// 启动线程
t2.start();
```
### 方法三，FutureTask配合Thread
FutureTask能够接收Callable类型的参数，**用来处理有返回结果的情况**
```java
// 创建任务对象
FutureTask<Integer> task = new FutureTask<>(() -> {
	System.out.println("hello");
	return 100;
}); 
// 创建线程对象
Thread t3 = new Thread(task, "t3");
// 启动线程
t3.start();
// 主线程阻塞，等待task执行完毕
Integer result = task.get();
```
## 2.2 线程运行原理
### 栈与栈帧
JVM由堆、栈、方法区组成，其中栈内存就是给线程用的，每个线程启动后，虚拟机会为其分配一块栈内存。
- 每个栈由多个**栈帧**（Frame）组成，对应着**每次方法调用时所占用的内存**
- 每个线程只能有一个**活动栈帧**，对应着当前**正在执行**的那个方法
### 线程上下文切换
因为以下一些原因导致CPU不再执行当前线程的代码，转而执行另一个线程的代码：
- 线程的CPU时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法
> 频繁的上下文切换会影响性能。

> 看到 p25
